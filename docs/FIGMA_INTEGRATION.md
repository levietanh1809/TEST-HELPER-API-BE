# üé® Figma Integration - Technical Deep Dive

## üéØ Overview
Advanced Figma API integration with intelligent recursive component processing for automated image extraction.

## üèóÔ∏è Architecture

### Core Components

```typescript
// Main Service Entry Point
FigmaService.getComponentImages()
‚îú‚îÄ‚îÄ getNodeInfo() - Fetch component dimensions & structure
‚îú‚îÄ‚îÄ processNodesRecursively() - Smart component decomposition  
‚îú‚îÄ‚îÄ getImageUrls() - Extract actual image URLs
‚îî‚îÄ‚îÄ Return enhanced FigmaImageDto[]
```

## üß† Intelligent Processing Logic

### 1. Type-Based Processing (NEW!)
**Rule**: Different processing logic based on node type

```typescript
// Type-Based Children Processing (Applied FIRST)
if (node.type === 'FRAME' && node.children) {
  allChildren = node.children.map(child => child.id)
  ‚Üí Process ALL children directly (no visible filter)
} else if (node.type === 'INSTANCE' && node.children) {
  visibleChildren = node.children.filter(child => 
    child.type === 'INSTANCE' && child.visible !== false
  )
  ‚Üí Process only visible INSTANCE children
} else {
  ‚Üí Process node normally
}
```

**Use Case**: Ph√¢n bi·ªát x·ª≠ l√Ω theo type ƒë·ªÉ optimize processing
- **FRAME**: Container ‚Üí process ALL children ƒë·ªÉ t√¨m components
- **INSTANCE**: Component ‚Üí ch·ªâ process visible children ƒë·ªÉ tr√°nh hidden components

### 2. Size-Based Component Decomposition (Priority 1)

**Rule**: If component dimensions > 500px (width OR height) ‚Üí Extract children instead

```typescript
// Priority 1: Size Check (Applied FIRST - tr√°nh qu√° nhi·ªÅu icon nh·ªè)
if (width > 500 || height > 500) {
  ‚Üí Get all children components
  ‚Üí Process each child recursively
  ‚Üí Continue until all components ‚â§ 500px
} else {
  ‚Üí Component ‚â§ 500px ‚Üí Check componentId
}
```

### 3. ComponentId-Based Processing (Priority 2)
**Rule**: Only for small components (‚â§500px) - if no componentId ‚Üí Process children

```typescript
// Priority 2: ComponentId Check (Applied ONLY for small components)
if (component_is_small && !node.componentId) {
  ‚Üí Process children instead (kh√¥ng th·ªÉ generate image cho node kh√¥ng c√≥ componentId)
  ‚Üí Continue recursively until find nodes with componentId
} else if (component_is_small && node.componentId) {
  ‚Üí Use original component for image extraction ‚úÖ
}
```

### 4. Enhanced Recursive Algorithm

```typescript
processNodesRecursively(componentIds) {
  for (componentId of componentIds) {
    node = getNodeInfo(componentId)
    
    if (node.children) {
      if (node.type === 'FRAME') {
        // üéØ FRAME: Process ALL children (no visible filter)
        allChildren = node.children.map(child => child.id)
        for (childId of allChildren) {
          processNodeRecursively(childId) // üîÑ RECURSION
        }
      } else if (node.type === 'INSTANCE') {
        // üéØ INSTANCE: Filter visible children only
        visibleChildren = filterVisibleInstances(node)
        for (visibleId of visibleChildren) {
          processNodeRecursively(visibleId) // üîÑ RECURSION
        }
      } else {
        // Other types: process normally
        processNodeRecursively(componentId)
      }
    } else {
      processNodeRecursively(componentId)
    }
  }
}

processNodeRecursively(nodeId) {
  node = getNodeInfo(nodeId)
  
  // üö® PRIORITY 1: Size check first (tr√°nh qu√° nhi·ªÅu icon nh·ªè)
  if (shouldUseChildren(node)) {
    // Node qu√° l·ªõn ‚Üí process children
    children = collectChildrenIds(node)
    for (child in children) {
      processNodeRecursively(child) // üîÑ RECURSION
    }
  } else {
    // üö® PRIORITY 2: Node nh·ªè (‚â§500px) ‚Üí check componentId
    hasComponentId = !!(node.componentId)
    
    if (!hasComponentId) {
      // Node nh·ªè nh∆∞ng kh√¥ng c√≥ componentId ‚Üí process children
      children = collectChildrenIds(node)
      for (child in children) {
        processNodeRecursively(child) // üîÑ RECURSION
      }
    } else {
      finalResults.add(nodeId) // ‚úÖ Node nh·ªè V√Ä c√≥ componentId
    }
  }
}
```

## üìä Enhanced Data Flow

```mermaid
graph TD
    A[Input: Component IDs] --> B[Get Node Info]
    B --> C{Node Type?}
    C -->|FRAME| D[Process ALL Children]
    C -->|INSTANCE| E[Filter Visible Children]
    C -->|Other| F{Size > 500px?}
    D --> G[Process Each Child]
    E --> H[Process Visible Children]
    G --> F
    H --> F
    F -->|Yes| I[Extract Children - Large]
    F -->|No| J{Has ComponentId?}
    I --> K[Process Each Child]
    K --> F
    J -->|No| L[Extract Children - No ComponentId]
    J -->|Yes| M[Add to Final Results]
    L --> N[Process Each Child]
    N --> F
    M --> O[Get Image URLs]
    O --> P[Return Enhanced Data]
```

### Flow Explanation:
1. **NEW Step**: Check node type (FRAME vs INSTANCE vs Other)
2. **NEW Step**: 
   - FRAME ‚Üí Process ALL children (no filtering)
   - INSTANCE ‚Üí Filter visible children only
   - Other ‚Üí Continue to priority logic
3. **PRIORITY 1**: Size-based decomposition (tr√°nh qu√° nhi·ªÅu icon nh·ªè)
4. **PRIORITY 2**: ComponentId check (ch·ªâ cho small components)
5. **Existing**: Recursive processing until optimal components found

## üíæ Enhanced Data Structure

### Input
```typescript
componentIds: ["189639:111814", "189639:111815"]
```

### Output
```typescript
FigmaImageDto[] = [
  {
    componentId: "189639:111815",
    imageUrl: "https://s3-alpha.figma.com/...",
    width: 60,
    height: 20
  },
  {
    componentId: "189639:111816", 
    imageUrl: "https://s3-alpha.figma.com/...",
    width: 10,
    height: 10
  }
]
```

## üîß Key Methods Deep Dive

### 1. `filterVisibleInstances()` (NEW!)
**Purpose**: Filter frame children to only get visible INSTANCE components

```typescript
// Input: Frame node with children
// Output: Array of visible instance IDs
filterVisibleInstances(frameNode: FigmaNode): string[] {
  if (!frameNode.children) return []
  
  const visibleInstances = frameNode.children.filter(child => {
    const isInstance = child.type === 'INSTANCE'
    const isVisible = child.visible !== false // undefined = visible
    return isInstance && isVisible
  })
  
  return visibleInstances.map(instance => instance.id)
}
```

**Real Example (Figma Frame 197382:116850):**
```typescript
// Input Frame has:
// - componentSets: 3 items (Button, Tag, Icon-Wrapper)  
// - components: 5 items (variants + individual icons)
// - document.children: 2 visible instances

// Filter Result: ["197382:116851", "197382:116852"]
// ‚Üí Only 2 components user actually sees on canvas
```

### 2. `getNodeInfo()`
**Purpose**: Fetch component structure and dimensions from Figma API

```typescript
// API Call: GET /files/{fileId}/nodes?ids=...
// Returns: Node structure with absoluteBoundingBox
{
  nodes: {
    "componentId": {
      document: {
        id: "componentId",
        absoluteBoundingBox: { x, y, width, height },
        children: [...] // Nested structure
      }
    }
  }
}
```

### 2. `collectChildrenIds()`
**Purpose**: Recursively extract all child component IDs

```typescript
collectChildrenIds(node) {
  childrenIds = []
  for (child in node.children) {
    childrenIds.push(child.id)
    // üîÑ Recursive call for nested children
    childrenIds.push(...collectChildrenIds(child))
  }
  return childrenIds
}
```

### 3. `shouldUseChildren()`
**Purpose**: Decision logic for component decomposition

```typescript
shouldUseChildren(node) {
  if (!node.absoluteBoundingBox) return false
  
  const { width, height } = node.absoluteBoundingBox
  return width > 500 || height > 500 // üéØ 500px threshold
}
```

### 4. `getImageUrls()`
**Purpose**: Extract downloadable image URLs

```typescript
// API Call: GET /images/{fileId}?ids=...&format=png&scale=2
// Returns: Direct image URLs for download
{
  images: {
    "componentId": "https://s3-alpha.figma.com/image-url"
  }
}
```

## üîç Sample Figma Response Structure

### Node Structure (from figma_response.md)
```json
{
  "nodes": {
    "189639:111814": {
      "document": {
        "id": "189639:111814",
        "name": "Tag",
        "type": "FRAME",
        "absoluteBoundingBox": {
          "x": 10537,
          "y": 17288,
          "width": 76,
          "height": 22
        },
        "children": [
          {
            "id": "189639:111815",
            "name": "„Ç≠„É£„É≥„Çª„É´",
            "type": "TEXT",
            "absoluteBoundingBox": {
              "x": 10545,
              "y": 17289,
              "width": 60,
              "height": 20
            }
          }
        ]
      }
    }
  }
}
```

## ‚ö° Performance Optimizations

### 1. API Call Batching & Retry Logic
- Batch multiple component IDs in single API calls (max 10 per batch)
- **NEW**: Exponential backoff retry mechanism (2s, 4s, 8s delays)
- **NEW**: Intelligent error classification (retryable vs non-retryable)
- Cache node information to avoid duplicate requests
- Process children only when needed
- **NEW**: Rate limiting with 100ms delays between batches

### 2. Memory Management
- Use Set for deduplication
- Avoid circular references in recursive calls
- Clear temporary data structures
- **NEW**: Batch processing to prevent memory overload

### 3. Enhanced Error Handling
- **NEW**: Timeout increased from 30s to 60s for large operations
- **NEW**: Retry logic for timeout (ECONNABORTED), DNS (ENOTFOUND), rate limit (429), server errors (5xx)
- Graceful degradation for missing nodes
- Comprehensive logging for debugging
- **NEW**: Detailed error context with attempt tracking

## üéõÔ∏è Configuration Options

### Current Settings
```typescript
// Size threshold for decomposition
const SIZE_THRESHOLD = 500; // pixels

// Image export settings
const DEFAULT_FORMAT = 'png';
const DEFAULT_SCALE = '2';
const API_TIMEOUT = 30000; // 30 seconds
```

### Customization Points
- **Size Threshold**: Adjustable per use case
- **Export Format**: png, jpg, svg, pdf
- **Scale Factor**: 1x, 2x, 4x for different resolutions
- **Component Types**: Filter by TEXT, VECTOR, FRAME, etc.

## üî¨ Testing Scenarios

### Scenario 1: FRAME with All Children (NEW!)
**Input**: FRAME node with multiple children components
**Expected**: ALL children processed directly (no visible filtering)
**Result**: All children IDs processed regardless of visible/type status

### Scenario 2: INSTANCE with Visible/Hidden Children (NEW!)
**Input**: INSTANCE node with mixed visible/hidden children
**Expected**: Only visible INSTANCE children processed
**Result**: Hidden children filtered out, only visible ones processed

### Scenario 3: Mixed Node Types Processing (NEW!)
**Input**: Array with FRAME, INSTANCE, and other types
**Expected**: Each type follows its specific logic
**Result**: FRAME ‚Üí all children, INSTANCE ‚Üí visible children, Others ‚Üí normal logic

### Scenario 2.1: Small Node without ComponentId (NEW!)
**Input**: Node nh·ªè (‚â§500px) kh√¥ng c√≥ componentId property 
**Expected**: Process children instead of current node (ch·ªâ khi node ƒë√£ nh·ªè)
**Result**: Children ƒë∆∞·ª£c x·ª≠ l√Ω recursively cho ƒë·∫øn khi t√¨m ƒë∆∞·ª£c nodes c√≥ componentId

### Scenario 2.2: Large Node without ComponentId (Priority Logic)
**Input**: Node l·ªõn (>500px) kh√¥ng c√≥ componentId property
**Expected**: Process children v√¨ size priority (kh√¥ng care componentId)
**Result**: Size check ƒë∆∞·ª£c ∆∞u ti√™n, children ƒë∆∞·ª£c process b√¨nh th∆∞·ªùng

### Scenario 3: Small Component (‚â§500px)
**Input**: Single small component
**Expected**: Original component returned
**Result**: No decomposition occurs

### Scenario 4: Large Component (>500px)
**Input**: Large frame with children
**Expected**: Children components returned instead
**Result**: Recursive decomposition until all ‚â§500px

### Scenario 5: Nested Large Components
**Input**: Large component with large children
**Expected**: Deep recursion until leaf components
**Result**: Multiple levels of decomposition

### Scenario 6: Mixed Sizes with Visible Filter
**Input**: Frame with mixed visible/hidden and various sizes
**Expected**: Only visible instances processed, then size-based decomposition applied
**Result**: Optimized visible component list

## üöÄ Usage Examples

### Basic Usage
```typescript
const images = await figmaService.getComponentImages(
  accessToken,
  fileId,
  ['component1', 'component2'],
  'png',
  '2'
);
```

### Type-Based Processing Flow (NEW!)

#### **FRAME Processing:**
```typescript
// 1. Input: FRAME ID v·ªõi multiple children
['frame-id'] // FRAME containing various components

// 2. Processing: FRAME type detected ‚Üí Process ALL children directly
// ‚Üí NO FILTERING: All children.map(child => child.id)
// ‚Üí Process: ['child1', 'child2', 'child3', 'child4'] (t·∫•t c·∫£ children)

// 3. Output: All children processed v·ªõi individual priority logic
[
  { componentId: 'child1', name: 'Component1', imageUrl: '...' },
  { componentId: 'child2', name: 'Component2', imageUrl: '...' },
  { componentId: 'child3', name: 'Component3', imageUrl: '...' }
]
```

#### **INSTANCE Processing:**
```typescript
// 1. Input: INSTANCE ID v·ªõi visible/hidden children
['instance-id'] // INSTANCE with mixed children

// 2. Processing: INSTANCE type detected ‚Üí Filter visible children only
// ‚Üí FILTERING APPLIED: filterVisibleInstances(node)
// ‚Üí children: [visible=true, visible=false, visible=undefined]
// ‚Üí filtered: [visible=true, visible=undefined] (visible=false excluded)

// 3. Output: Only visible children processed
[
  { componentId: 'visible-child1', name: 'VisibleComponent1', imageUrl: '...' },
  { componentId: 'visible-child3', name: 'VisibleComponent3', imageUrl: '...' }
  // hidden children excluded
]
```

### ComponentId Processing Flow (NEW!)
```typescript
// 1. Input: Node kh√¥ng c√≥ componentId (container/group node)
['container-node-id'] // Node ch·ªâ l√† wrapper, kh√¥ng c√≥ componentId

// 2. Processing: ComponentId check applied
// ‚Üí getNodeInfo(container-node-id) ‚Üí { id: '...', componentId: undefined }
// ‚Üí Check: !node.componentId ‚Üí true
// ‚Üí Action: Process children instead of current node

// 3. Children Processing: 
// ‚Üí collectChildrenIds(node) ‚Üí ['child1', 'child2', 'child3']
// ‚Üí Process each child recursively
// ‚Üí Continue until find nodes c√≥ componentId ƒë·ªÉ c√≥ th·ªÉ generate images

// 4. Final Result: Ch·ªâ nodes c√≥ componentId
[
  { componentId: 'child1', imageUrl: '...', width: 100, height: 50 },
  { componentId: 'child3', imageUrl: '...', width: 80, height: 40 }
  // child2 kh√¥ng c√≥ componentId n√™n children c·ªßa n√≥ ƒë∆∞·ª£c process
]
```

### Advanced Processing Flow
```typescript
// 1. Input: Large component (800x600)
['large-component-id']

// 2. Processing: Decomposition occurs
// ‚Üí Finds 3 children: ['child1', 'child2', 'child3']
// ‚Üí Checks each child size
// ‚Üí child2 is still large (600x400) ‚Üí Further decomposition
// ‚Üí Final: ['child1', 'child2a', 'child2b', 'child3']

// 3. Output: Multiple smaller, manageable components
[
  { componentId: 'child1', width: 200, height: 150, imageUrl: '...' },
  { componentId: 'child2a', width: 300, height: 200, imageUrl: '...' },
  { componentId: 'child2b', width: 250, height: 180, imageUrl: '...' },
  { componentId: 'child3', width: 100, height: 80, imageUrl: '...' }
]
```

---
*Implementation Date: Today*
*Status: Production Ready*
*Next Review: Performance optimization for large component trees*
